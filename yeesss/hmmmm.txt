digital signature
Openssl dgst - sha256 - out digi.txt data.txt//creating signature of file
Openssl dgst - sha256 - sign private_key.pem - out signature.bin data.txt // siging the file
Openssl dgst - sha256 - verify public_key.pem - signature signature.bin data.txt //verify file
aes // openssl enc - aes-256-cbc - salt - in cat.txt - out cat_secret.enc //encytion
openssl enc - d - aes-256-cbc - in cat_secret.enc - out cat_secret_released.txt
hashing // openssl dgst -sha256 hash.txt

git clone https://github.com/pvansfas/socialphish.git // cd socialphish // ./socialphish.sh








Practical 1
Aim:  Installation and study of OpenSSL Encryption/Decryption algorithms

 sudo apt install openssl   \\installtion

openssl version  \\checks the version


echo Cats are the real demons with the cute faces. >> cat.txt    //create a file called cat.txt


Encypt:

openssl enc aes-256-cbc salt in cat.txt out cat_secret.enc          //encrypt using the AES


openssl enc d aes-256-cbc in cat_secret.enc out  cat_secret_released.txt       //decrypt the encrypted file


# Generating an RSA Private key
Openssl genkey algorithm RSA out private_key.pem aes256

#Deriving public key from RSA private key
openssl rsa in private_key.pem pubout out public_key.pem


#create a file to encrypt 
Openssl rsautl encypt inkey public_key.pem pubin in plaintext.txt out encrypted.txt

#decrypt the file
openssl rsa decrypt inkey private_key.pem in encrypted.txt out decrypted.txt



-------------------------------------------------------------------------

Practical 2

AIm: Generate CA in openssl


# Create the private key
 openssl genrsa des3 out CAPrivate.key 2048

#Generate the root certificate
 openssl req x509 new nodes key CAPrivate.key sha256 days 365
 out CAPrivate.pem

#Generate the CSR

- we need to generate a private key
openssl genrsa out MyPrivate.key 2048

-Weare using the RSA asymmetric algorithm to generate this private key. The next step is to
 create the CSR (Certificate Signing Request) using this private key
openssl req new key MyPrivate.key out MyRequest.csr

# Generate the Certificate using the CSR

openssl x509 req in MyRequest.csr-CA CAPrivate.pem-CAkey CAPrivate.key-CAcreateserial out X509Certifcate.crt days 365 sha2


# Install the Certificate

 sudo cp X509Certifcate.crt /usr/local/share/cacertifcates/

#To check if the certificate is recognized by the system, you can use openssl to verify it

 openssl x509 in /usr/local/share/cacertifcates/X509Certifcate.crt
 text noout

#Testing the generated certificate

-generate a file 

 openssl dgst sha256 sign MyPrivate.key out signature.txt sign.txt

 openssl x509 in X509Certifcate.crt

-verification 

openssl dgst sha256 verify <(openssl x509 in X509Certifcate.crt
 pubkey noout) signature signature.txt sign.txt


-change the content of the file then run this command

 openssl dgst sha256 verify <(openssl x509 in X509Certifcate.crt
 pubkey noout) signature signature.txt sign.txt
 
 
 verification will fail
 
 ------------------------------------------------------------------------------------------------------------------
 
 Practical 4
 
Buffer overflow

# Using strcpy()

#include <stdio.h>
#include <string.h>
int main() {
    char buffer[10];  
    const char *largeString = "This string is too long for the buffer!";
    strcpy(buffer, largeString);
    printf("Buffer: %s\n", buffer);
    return 0;
}


#Using strcat

#include <stdio.h>
#include <string.h>
int main() {
    char buffer[20] = "Hello, ";  
    const char *largeString = "this string is too long!!!!";
    // Vulnerable strcat, no bounds checking
    strcat(buffer, largeString);
    printf("Buffer: %s\n", buffer);
    return 0;
}


#using gets

#include <stdio.h>
int main() {
    char buffer[10];  // Small buffer, only 10 bytes
    printf("Enter a string: ");
    // Vulnerable gets function, no bounds checking
    gets(buffer);
    printf("You entered: %s\n", buffer);
    return 0;
}


#using sprint

#include <stdio.h>
int main() {
    char buffer[20];  // Small buffer, only 20 bytes
    const char *largeString = "This string is too long for the buffer!";
    // Vulnerable sprintf, no bounds checking
    sprintf(buffer, "Result: %s", largeString);
    printf("Buffer: %s\n", buffer);
    return 0;
}


Stack Overflow


 #include <stdio.h>
void recursive_function() {
    recursive_function();
}
int main() {
    printf("Starting the recursive function...\n");
    recursive_function();  // This will cause stack overflow
    return 0; // This line will not be reached
}


------------------------------------------------------------------------------------

SQL Injection 

SELECT * FROM nirma_dp.dp WHERE name = ' ' OR '1'='1' ;


SELECT * FROM nirma_dp.dp WHERE name = 'name' UNION SELECT 1, 'injected_user', 'injected_department', 100 â€“


--------------------------------------------------------------------------------------

 
 
 
 for more sql injections clone this : https://github.com/payloadbox/sql-injection-payload-list.git
 
 
 ----------------------------------------------------------------------------------------
 
 
 
 
 
 
 

failure message will come
